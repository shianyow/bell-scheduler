<!DOCTYPE html>
<html lang="zh-Hant">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dhamma Gong v2</title>
  <style>
    .play-button {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 30vh;
      background: #707070;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      color: #fff;
      font-size: 5vh;
      font-weight: bold;
      margin-bottom: 10px;
    }

    .play-button.flash {
      animation: flash-bg 3s ease-in-out infinite;
    }

    @keyframes flash-bg {
      0% {
        background: #707070;
      }

      50% {
        background: #212121;
      }

      100% {
        background: #707070;
      }
    }

    .play-text {
      flex-grow: 1;
    }

    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #f5f5f5;
    }

    .container {
      max-width: 100%;
      margin: 0 auto;
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, .1);
    }

    .status {
      padding: 10px;
      margin-bottom: 15px;
      border-radius: 4px;
    }

    .status.loading {
      background: #d1ecf1;
      color: #0c5460;
    }

    .status.success {
      background: #d4edda;
      color: #155724;
    }

    .status.error {
      background: #f8d7da;
      color: #721c24;
    }

    .hidden {
      display: none;
    }

    .date-block {
      border: 1px solid #ccc;
      padding: 10px;
      margin-bottom: 8px;
      background: #fff;
    }
    /* ä»Šæ—¥å¼·èª¿ */
    .date-block.today {
      border-left: 4px solid #28a745; /* ç¶ è‰²å·¦é‚Šæ¢ */
      background: #f5fff7;            /* å¾ˆæ·¡çš„ç¶ åº• */
    }
    /* æ§åˆ¶åˆ—ç½®é ‚ */
    .controls {
      position: sticky;
      top: 0;
      background: #fff;
      z-index: 5;
      padding: 8px 0;
      box-shadow: 0 2px 6px rgba(0, 0, 0, .04);
    }
    /* Logs å›ºå®šé«˜åº¦èˆ‡æ»¾å‹• */
    #bell-log, #debug-log {
      max-height: 200px;
      overflow: auto;
    }
    /* ç‹€æ…‹åˆ— + å·¥å…·æŒ‰éˆ•æ’åˆ— */
    .status-row { display: flex; align-items: center; gap: 8px; }
    .status-row .spacer { flex: 1; }
    .tool-btn { background: transparent; border: 1px solid #ddd; color: #555; padding: 2px 10px; border-radius: 4px; font-size: inherit; }
    .tool-btn:hover { background: #f3f3f3; }
    .tool-btn.active { background: #eef6ff; color: #0b74da; border-color: #b6dbff; }
    /* Debug å€å¡Šå›ºå®šæ¨™é ­ */
    #debug-log { background:#222; color:#0f0; }
    #debug-log .debug-header { position: sticky; top: 0; background:#111; color:#9f9; padding:6px 8px; border-bottom:1px solid #333; display:flex; align-items:center; gap:8px; z-index:1; }
    #debug-log .debug-header label { font-size:12px; color:#9f9; }
    #debug-entries { padding:8px; font-size:12px; }
  </style>
  <script>
    // Debug ç­‰ç´šï¼š0=é—œé–‰, 1=ä¸€èˆ¬, 2=è©³ç´°
    function debugLog(msg, level = 1) {
      const threshold = window.__debugLevel ?? 1;
      if (level > threshold) return;
      const now = new Date().toLocaleTimeString();
      const entries = document.getElementById('debug-entries');
      if (typeof msg !== 'string') msg = JSON.stringify(msg);
      if (entries) {
        const row = document.createElement('div');
        row.textContent = `[${now}] ${msg}`;
        entries.appendChild(row);
        // é™åˆ¶æœ€å¤§è¡Œæ•¸ï¼Œé¿å…é•·æ™‚é–“é‹è¡Œé€ æˆ DOM éå¤§
        const MAX_DEBUG_LINES = 200;
        const nodes = entries.querySelectorAll('div');
        const overflow = nodes.length - MAX_DEBUG_LINES;
        if (overflow > 0) {
          for (let i = 0; i < overflow; i++) nodes[i].remove();
        }
        const container = document.getElementById('debug-log');
        if (container) container.scrollTop = container.scrollHeight;
      }
      try { console.log('[DEBUG]', msg); } catch (_) { }
    }
  </script>
</head>

<body>
  <button class="play-button" onclick="playAlarm()">
    <div class="play-text">é»æ­¤æ‰‹å‹•æ•²é˜<br />â–¶ï¸</div>
  </button>

  <div class="container">
    <div class="status-row" style="margin-bottom:8px;">
      <div id="status" class="status hidden"></div>
      <div class="spacer"></div>
      <button id="tools-btn" class="tool-btn" title="é¡¯ç¤º Debug Log">ğŸ”</button>
    </div>
    <div id="audio-unlock" class="status">è«‹é»æ“Šç•«é¢ä»¥å•Ÿç”¨é˜è²ğŸ”“</div>
    <div id="debug-log" style="display:none; max-height:200px; overflow:auto; margin-bottom:12px; border-radius:6px;">
      <div class="debug-header">
        <span style="font-weight:600;">Debug Log</span>
        <div class="spacer"></div>
        <select id="debug-level-select" style="font-size:12px; background:#1a1a1a; color:#9f9; border:1px solid #333; border-radius:4px; padding:2px 6px;">
          <option value="0">0 é—œé–‰</option>
          <option value="1" selected>1 ä¸€èˆ¬</option>
          <option value="2">2 è©³ç´°</option>
        </select>
      </div>
      <div id="debug-entries"></div>
    </div>
    <div id="bell-log" style="background:#fff;border:1px solid #ddd;border-radius:6px;padding:8px;margin-bottom:12px;">
    </div>
    <div id="date-list"></div>
  </div>

  <audio id="alarm-sound" type="audio/mp3" preload="auto">
    <source src="">
  </audio>

  <script>
    // å…§åµŒé˜è²éŸ³æª”ï¼ˆèˆ‡èˆŠç‰ˆä¸€è‡´ï¼‰
    <?!= include('bell2nrjs') ?>

    const dateList = document.getElementById('date-list');
    const alarmSound = document.getElementById('alarm-sound');
    let source = alarmSound.querySelector('source');
    if (!source) { source = document.createElement('source'); alarmSound.appendChild(source); }
    source.src = BELL_BASE64; alarmSound.load();
    // æ˜ç¢ºè¨­å®šéŸ³é‡èˆ‡éœéŸ³ç‹€æ…‹
    alarmSound.muted = false;
    alarmSound.volume = 1.0;

    // Web Audioï¼ˆiOS å‹å–„ï¼‰ï¼šå–®ä¸€ AudioContextã€é å…ˆè§£ç¢¼éŸ³æª”ï¼Œä¹‹å¾Œç”¨ BufferSource ç–ŠåŠ æ’­æ”¾
    let audioCtx = null;      // AudioContext
    let bellBuffer = null;    // è§£ç¢¼å¾Œçš„ AudioBuffer
    let gainNode = null;      // éŸ³é‡æ§åˆ¶

    // éŸ³è¨Šè§£é–
    const audioUnlockDiv = document.getElementById('audio-unlock');
    let audioUnlocked = false;
    function showAudioUnlockMsg(msg) { audioUnlockDiv.textContent = msg; audioUnlockDiv.classList.remove('hidden'); }
    function hideAudioUnlockMsg() { audioUnlockDiv.classList.add('hidden'); }
    async function unlockAudio() {
      if (audioUnlocked) return;
      try {
        // 1) å˜—è©¦å»ºç«‹/æ¢å¾© Web Audio Context
        const AC = window.AudioContext || window.webkitAudioContext;
        if (AC) {
          if (!audioCtx) {
            audioCtx = new AC();
            gainNode = audioCtx.createGain();
            gainNode.gain.value = 1.0;
            gainNode.connect(audioCtx.destination);
          }
          if (audioCtx.state === 'suspended') { await audioCtx.resume(); }
          // 2) é å…ˆè§£ç¢¼ BELL_BASE64ï¼ˆå…ˆ atobï¼Œå†å¤±æ•—æ™‚ fallback fetchï¼‰
          if (!bellBuffer) {
            let decoded = false;
            try {
              const commaIdx = BELL_BASE64.indexOf(',');
              const b64 = commaIdx >= 0 ? BELL_BASE64.slice(commaIdx + 1) : BELL_BASE64;
              const binary = atob(b64);
              const len = binary.length;
              const bytes = new Uint8Array(len);
              for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
              debugLog(`Decoding bell buffer (atob), bytes=${len}`);
              bellBuffer = await new Promise((res, rej) => { audioCtx.decodeAudioData(bytes.buffer, res, rej); });
              decoded = true;
              debugLog(`Bell buffer decoded (atob): duration=${bellBuffer.duration.toFixed(2)}s`);
            } catch (e1) {
              debugLog('decodeAudioData via atob failed: ' + (e1?.message || e1));
              try {
                const resp = await fetch(BELL_BASE64);
                const arr = await resp.arrayBuffer();
                debugLog(`Decoding bell buffer (fetch), bytes=${arr.byteLength}`);
                bellBuffer = await new Promise((res, rej) => { audioCtx.decodeAudioData(arr, res, rej); });
                decoded = true;
                debugLog(`Bell buffer decoded (fetch): duration=${bellBuffer.duration.toFixed(2)}s`);
              } catch (e2) {
                debugLog('decodeAudioData via fetch failed: ' + (e2?.message || e2));
              }
            }
            if (!decoded) {
              debugLog('Bell buffer not decoded, will fallback to HTMLAudio path.');
            }
          }
        }
        // 3) åŒæ™‚ä¹Ÿå˜—è©¦è§£é– HTMLAudioï¼ˆåšç‚ºå¾Œæ´ï¼‰
        try {
          alarmSound.muted = true;
          await alarmSound.play();
          alarmSound.pause(); alarmSound.currentTime = 0; alarmSound.muted = false;
        } catch (_) { /* ignore */ }

        audioUnlocked = true;
        showAudioUnlockMsg('éŸ³è¨Šå·²è§£é–ï¼ğŸ”Š');
        setTimeout(hideAudioUnlockMsg, 1200);
      } catch (_) {
        showAudioUnlockMsg('è«‹é»æ“Šç•«é¢ä»¥å•Ÿç”¨é˜è²ğŸ”“');
      }
    }
    window.addEventListener('touchstart', unlockAudio, { once: true });
    window.addEventListener('click', unlockAudio, { once: true });

    // ç­‰å¾…éŸ³è¨Šè§£é–ï¼ˆé¿å…é¦–æ¬¡é»æ“Šæ™‚è§£é–èˆ‡æ’­æ”¾ç«¶æ…‹ï¼‰
    async function ensureAudioUnlocked(timeoutMs = 1200) {
      if (audioUnlocked) return true;
      try { await unlockAudio(); } catch (_) { }
      const start = Date.now();
      while (!audioUnlocked && (Date.now() - start) < timeoutMs) {
        await new Promise(r => setTimeout(r, 50));
      }
      if (!audioUnlocked) { showAudioUnlockMsg('è«‹é»æ“Šç•«é¢ä»¥å•Ÿç”¨é˜è²ğŸ”“'); }
      return audioUnlocked;
    }

    // ç‹€æ…‹é¡¯ç¤º
    function showStatus(message, type = 'loading') {
      const el = document.getElementById('status');
      el.textContent = message; el.className = `status ${type}`; el.classList.remove('hidden');
    }
    function hideStatus() { document.getElementById('status').classList.add('hidden'); }

    // åµæ¸¬æ˜¯å¦åœ¨ GAS åŸ·è¡Œç’°å¢ƒ
    function isGASEnv() {
      return (typeof google !== 'undefined' && google.script && google.script.run);
    }

    // è³‡æ–™æ¨¡å‹ï¼ˆèˆ‡èˆŠç‰ˆæ¸²æŸ“çµæ§‹ä¸€è‡´ï¼‰
    let alarms = []; // [{ date: 'YYYY-MM-DD', times: ['HH:MM', ...], bellTypes: { 'HH:MM': bellType|string|number } }]
    let bellConfig = {}; // { bellType: repeat }

    function renderAlarms() {
      dateList.innerHTML = '';
      const todayStr = getTodayDateFormatted();
      alarms.forEach(a => {
        const block = document.createElement('div');
        block.className = 'date-block' + (a.date === todayStr ? ' today' : '');
        block.innerHTML = `<h3>${a.date}</h3><p>ğŸ”” ${a.times.join(', ')}</p>`;
        dateList.appendChild(block);
      });
    }

    function getTodayDateFormatted() {
      const today = new Date();
      const y = today.getFullYear();
      const m = String(today.getMonth() + 1).padStart(2, '0');
      const d = String(today.getDate()).padStart(2, '0');
      return `${y}-${m}-${d}`;
    }

    function generateDateArray(startDateStr, days) {
      const result = []; const start = new Date(startDateStr);
      for (let i = 0; i < days; i++) { const dt = new Date(start); dt.setDate(start.getDate() + i); result.push(dt.toISOString().split('T')[0]); }
      return result;
    }

    // bell æ’­æ”¾
    let isAlarmPlaying = false; let pendingNextTimeout = null;
    // ç¬¬ä¸€è²éŸ³é‡è¨­å®šï¼ˆå¯èª¿ï¼‰
    const FIRST_STRIKE_VOLUME = 0.20;   // ç¬¬ä¸€è²ç›®æ¨™éŸ³é‡ï¼ˆå…¶é¤˜ç‚º 1.0ï¼‰
    const FIRST_STRIKE_ATTACK_MUTE_MS = 0; // ç¬¬ä¸€è²å‰ 30ms éœéŸ³ï¼ˆéæ·¡å…¥ï¼‰ï¼Œé™ä½èµ·å§‹æ•²æ“Šæ„Ÿ
    // è¿½è¹¤ç›®å‰æ­£åœ¨æ’­æ”¾çš„éŸ³è»Œ
    const activeAudios = new Set();    // HTMLAudioElement å¯¦ä¾‹
    const activeSources = new Set();   // Web Audio BufferSource å¯¦ä¾‹
    function playVisualAlarm(enable = true) { const btn = document.querySelector('.play-button'); enable ? btn.classList.add('flash') : btn.classList.remove('flash'); }
    function updatePlayButton(isPlaying = false) { const t = document.querySelector('.play-text'); if (!t) return; t.innerHTML = isPlaying ? 'é»æ­¤åœæ­¢é˜è²<br/>â¹ï¸' : 'é»æ­¤æ‰‹å‹•æ•²é˜<br/>â–¶ï¸'; }
    function playSingleAlarm(current, total) {
      // å°šæœªè§£é–æ™‚é¿å…è§¸ç™¼ç€è¦½å™¨é™åˆ¶
      if (!audioUnlocked) { showAudioUnlockMsg('è«‹é»æ“Šç•«é¢ä»¥å•Ÿç”¨é˜è²ğŸ”“'); return; }
      // å„ªå…ˆä½¿ç”¨ Web Audioï¼ˆiOS æ›´ç©©å®šï¼‰ï¼Œå¦å‰‡é€€å› HTMLAudio
      if (audioCtx && bellBuffer) {
        try {
          if (audioCtx.state === 'suspended') { audioCtx.resume().catch(() => { }); }
          const src = audioCtx.createBufferSource();
          src.buffer = bellBuffer;
          // é‡å°æ¯ä¸€è²å»ºç«‹ç¨ç«‹å¢ç›Šæ§åˆ¶ï¼šç¬¬ä¸€è² 0.5ï¼Œå…¶é¤˜ 1.0ï¼ˆä¸å½±éŸ¿å…¶ä»–åŒæ™‚æ’­æ”¾çš„éŸ³è»Œï¼‰
          const perStrikeGain = audioCtx.createGain();
          const t0 = audioCtx.currentTime;
          const vol = (current === 1 ? FIRST_STRIKE_VOLUME : 1.0);
          if (current === 1) {
            // iOS å¯æ„ŸçŸ¥ï¼šå…ˆéœéŸ³ä¸€å°æ®µå†åˆ‡åˆ°ç›®æ¨™éŸ³é‡ï¼ˆæ­¥é€²ï¼Œéæ·¡å…¥ï¼‰
            perStrikeGain.gain.setValueAtTime(0.0, t0);
            perStrikeGain.gain.setValueAtTime(vol, t0 + FIRST_STRIKE_ATTACK_MUTE_MS / 1000);
          } else {
            perStrikeGain.gain.setValueAtTime(1.0, t0);
          }
          src.connect(perStrikeGain);
          perStrikeGain.connect(gainNode || audioCtx.destination);
          activeSources.add(src);
          src.onended = function () { try { src.disconnect(); } catch (_) { } activeSources.delete(src); };
          // ç¨å¾®å»¶é²å•Ÿå‹•ï¼Œç¢ºä¿å¢ç›Šå·²è¨­å®šï¼ˆiOS ç›¸å®¹æ€§ï¼‰
          src.start(t0 + 0.01);
          debugLog(`Bell played (WebAudio): ${current}/${total} vol=${vol}`);
          return;
        } catch (e) {
          debugLog('webaudio play error:' + e);
        }
      }
      // å¾Œæ´ï¼šHTMLAudio æ–°å¯¦ä¾‹ï¼ˆæ³¨æ„ï¼šæœªè§£é–æ™‚æœƒè¢«é˜»æ“‹ï¼Œå› æ­¤å‰é¢å·² returnï¼‰
      const a = new Audio();
      a.src = BELL_BASE64;
      a.muted = false;
      if (current === 1) {
        // HTMLAudioï¼šå…ˆéœéŸ³ 30msï¼Œå†åˆ‡åˆ°ç›®æ¨™éŸ³é‡ï¼ˆæ­¥é€²ï¼‰
        a.volume = 0.0;
        setTimeout(() => { try { a.volume = FIRST_STRIKE_VOLUME; } catch (_) {} }, FIRST_STRIKE_ATTACK_MUTE_MS);
      } else {
        a.volume = 1.0;
      }
      activeAudios.add(a);
      a.onended = function () { try { a.src = ''; } catch (_) { } activeAudios.delete(a); };
      a.play().catch((e) => debugLog('play error:' + e));
      debugLog(`Bell played (HTMLAudio): ${current}/${total} vol=${current === 1 ? FIRST_STRIKE_VOLUME : 1.0}`);
    }
    function stopAlarm() {
      if (!isAlarmPlaying) return;
      if (pendingNextTimeout) { clearTimeout(pendingNextTimeout); pendingNextTimeout = null; }
      // åœæ­¢æ‰€æœ‰é‚„åœ¨æ’­æ”¾çš„ HTMLAudio å¯¦ä¾‹
      activeAudios.forEach((a) => {
        try { a.pause(); } catch (_) { }
        try { a.src = ''; } catch (_) { }
      });
      activeAudios.clear();
      // åœæ­¢æ‰€æœ‰ Web Audio BufferSource
      activeSources.forEach((s) => { try { s.stop(0); } catch (_) { } try { s.disconnect(); } catch (_) { } });
      activeSources.clear();
      // åŒæ™‚ä¹Ÿé‡ç½®é è¼‰ç”¨çš„ alarmSoundï¼ˆä¿æŒåŸæœ‰è¡Œç‚ºï¼‰
      try { alarmSound.pause(); alarmSound.currentTime = 0; } catch (_) { }
      playVisualAlarm(false);
      updatePlayButton(false);
      isAlarmPlaying = false;
    }
    async function playAlarmSequence(times = 1, trigger = 'è‡ªå‹•') {
      if (times < 1) return;
      // å…ˆç¢ºä¿å·²è§£é–
      const ok = await ensureAudioUnlocked();
      if (!ok) return;
      // å˜—è©¦æ¢å¾©è¢«æš«åœçš„ AudioContext
      if (audioCtx && audioCtx.state === 'suspended') { try { await audioCtx.resume(); } catch (_) { } }
      isAlarmPlaying = true; playVisualAlarm(true); updatePlayButton(true);
      let count = 0;
      // æ¯è²ä¹‹é–“çš„è§¸ç™¼é–“éš”ï¼ˆæ¯«ç§’ï¼‰ã€‚éœ€æ±‚ï¼šæ¯ 15 ç§’ä¸€è²ï¼ˆéŸ³æª”ç´„ 17 ç§’ï¼Œæœƒç”¢ç”Ÿé©åº¦é‡ç–Šï¼‰ã€‚
      const strikeIntervalMs = 15000;
      // é˜è²æ’­æ”¾ç´€éŒ„ï¼ˆèˆ‡èˆŠç‰ˆä¸€è‡´ï¼‰
      logBellPlay(trigger, times);
      function playNext() {
        if (!isAlarmPlaying) return;
        if (count >= times) { playVisualAlarm(false); updatePlayButton(false); isAlarmPlaying = false; return; }
        playSingleAlarm(count + 1, times);
        count++;
        pendingNextTimeout = setTimeout(playNext, strikeIntervalMs);
      }
      playNext();
    }
    async function playAlarm() { if (isAlarmPlaying) stopAlarm(); else await playAlarmSequence(4, 'æ‰‹å‹•'); }

    function deletePastAlarms() { const today = getTodayDateFormatted(); alarms = alarms.filter(a => a.date >= today); }
    function sortAlarms() { alarms.sort((a, b) => new Date(a.date) - new Date(b.date)); alarms.forEach(a => a.times.sort((x, y) => x.localeCompare(y))); }

    // æ’­æ”¾é˜è²ç´€éŒ„ï¼ˆèˆ‡èˆŠç‰ˆä¸€è‡´ï¼‰
    function logBellPlay(type, times) {
      const logDiv = document.getElementById('bell-log');
      if (!logDiv) return;
      const now = new Date();
      const nowStr = now.toLocaleTimeString();
      const msg = `[${nowStr}] ${type} æ’­æ”¾é˜è² x${times}`;
      logDiv.innerHTML = `<div>${msg}</div>` + logDiv.innerHTML;
      const logs = logDiv.querySelectorAll('div');
      if (logs.length > 20) { for (let i = 20; i < logs.length; i++) logs[i].remove(); }
    }

    function runEveryMinuteAtZeroSecond() {
      const now = new Date();
      const next = new Date(now);
      next.setSeconds(0);
      next.setMilliseconds(0);
      next.setMinutes(now.getMinutes() + 1);
      const delay = next - now;
      debugLog(`[tick] schedule next @ ${next.toLocaleTimeString()} (delay=${delay}ms)`, 2);
      setTimeout(() => {
        // åœ¨å›å‘¼ç•¶ä¸‹é‡æ–°å–å¾—æ™‚é–“ï¼Œé¿å…è¨ˆæ™‚å™¨æå‰æ–¼ :00 è§¸ç™¼é€ æˆèª¤åˆ¤
        const t = new Date();
        const hh = String(t.getHours()).padStart(2, '0');
        const mm = String(t.getMinutes()).padStart(2, '0');
        const currentTime = `${hh}:${mm}`;
        const today = getTodayDateFormatted();

        // æ¯åˆ†é˜å»é‡ï¼šé¿å…æ–¼é‚Šç•ŒæŠ–å‹•è€Œé‡è¤‡æ’­æ”¾
        window.__lastAutoFireKey = window.__lastAutoFireKey || '';
        const currentKey = `${today} ${currentTime}`;

        const hasAlarms = !!(alarms && alarms.length > 0);
        const dateMatch = hasAlarms ? (alarms[0].date === today) : false;
        const timeMatch = hasAlarms && dateMatch ? alarms[0].times.includes(currentTime) : false;
        debugLog(`[tick] now=${today} ${currentTime}, hasAlarms=${hasAlarms}, dateMatch=${dateMatch}, timeMatch=${timeMatch}` , 2);
        if (hasAlarms && dateMatch && timeMatch) {
          if (window.__lastAutoFireKey === currentKey) {
            // å·²æ–¼æœ¬åˆ†é˜è§¸ç™¼éï¼Œé¿å…é‡è¤‡
            debugLog(`[tick] duplicate suppressed for ${currentKey}`, 2);
          } else {
            window.__lastAutoFireKey = currentKey;
            const v = alarms[0].bellTypes[currentTime] ?? 1;
            const repeat = (typeof v === 'number') ? v : (bellConfig[String(v)] || 1); // ä»¥ BellConfig æ±ºå®šæ•²å¹¾è²
            debugLog(`è‡ªå‹•æ’­æ”¾é˜è²: repeat=${repeat}`);
            playAlarmSequence(repeat, 'è‡ªå‹•');
          }
        } else {
          if (!hasAlarms) debugLog('[tick] skip: no alarms');
          else if (!dateMatch) debugLog(`[tick] skip: date not match (first=${alarms[0]?.date}, today=${today})`);
          else if (!timeMatch) debugLog(`[tick] skip: ${currentTime} not in [${alarms[0].times.join(', ')}]`, 2);
        }
        runEveryMinuteAtZeroSecond();
      }, delay);
    }

    // æ¯æ—¥ 00:00 æ¸…ç†éå»æ—¥æœŸä¸¦åˆ·æ–°åˆ—è¡¨
    function scheduleMidnightTask() {
      const now = new Date();
      const nextMidnight = new Date(now);
      nextMidnight.setDate(now.getDate() + 1);
      nextMidnight.setHours(0, 0, 0, 0);
      const delay = nextMidnight - now;
      debugLog(`[midnight] schedule @ ${nextMidnight.toLocaleString()} (in ${delay}ms)`);
      setTimeout(() => {
        try {
          debugLog('[midnight] running: deletePastAlarms + refresh');
          deletePastAlarms();
          sortAlarms();
          renderAlarms();
        } finally {
          scheduleMidnightTask();
        }
      }, delay);
    }

    // è®€å– v2 API
    async function fetchV2() {
      debugLog('Calling v2/course ...');
      if (isGASEnv()) {
        // ç›´æ¥å‘¼å« GAS å‡½å¼ï¼Œé¿å…å› éƒ¨ç½²æˆ–æ¬Šé™å°è‡´çš„ HTML å›å‚³
        return await new Promise((resolve, reject) => {
          try {
            google.script.run
              .withSuccessHandler((data) => { try { debugLog('v2/course response (GAS): ' + JSON.stringify(data)); } catch (_) { }; resolve(data); })
              .withFailureHandler(err => {
                const msg = (err && err.message) ? err.message : (typeof err === 'string' ? err : 'GAS error');
                reject(new Error(msg));
              })
              .exportBellScheduleJSONV2();
          } catch (e) { reject(e); }
        });
      }
      // é GAS ç’°å¢ƒå‚™æ´ï¼šfetch è·¯ç”±ç«¯é»
      const apiUrl = `${window.location.href.split('?')[0]}?path=v2/course`;
      const resp = await fetch(apiUrl, { headers: { 'Accept': 'application/json' } });
      const text = await resp.text();
      if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${text.slice(0, 120)}`);
      try { const data = JSON.parse(text); try { debugLog('v2/course response (fetch): ' + JSON.stringify(data)); } catch (_) { }; return data; } catch (e) { throw new Error("Unexpected token '<', response is not JSON"); }
    }

    function applyV2Data(v2) {
      // v2 compact: { CourseSchedule:[{startDate,courseType}], CourseTypeDays:{ct:[patternKey...]}, DailyPatternBells:{ct:{patternKey:[{time,bellType}]}} , BellConfig }
      alarms = [];
      bellConfig = v2.BellConfig || {};
      const courseSchedule = Array.isArray(v2.CourseSchedule) ? v2.CourseSchedule : [];
      const ctd = v2.CourseTypeDays || {};
      const dpb = v2.DailyPatternBells || {};

      courseSchedule.forEach(sch => {
        const ct = sch.courseType;
        const dayKeys = Array.isArray(ctd[ct]) ? ctd[ct] : [];
        const dates = generateDateArray(sch.startDate, dayKeys.length);
        dates.forEach((date, idx) => {
          const key = dayKeys[idx]; if (!key) return;
          const bells = (((dpb || {})[ct] || {})[key]) || [];
          const times = []; const bellTypes = {};
          bells.forEach(b => { if (b && b.time) { times.push(b.time); bellTypes[b.time] = (b.bellType !== undefined ? b.bellType : b.count); } });
          const exist = alarms.find(a => a.date === date);
          if (exist) {
            times.forEach(t => { if (!exist.times.includes(t)) exist.times.push(t); exist.bellTypes[t] = bellTypes[t]; });
            exist.times.sort((x, y) => x.localeCompare(y));
          } else {
            alarms.push({ date, times: Array.from(new Set(times)).sort((x, y) => x.localeCompare(y)), bellTypes });
          }
        });
      });

      deletePastAlarms(); sortAlarms(); renderAlarms();
    }

    // keepaliveï¼šå–å¾—ç‹€æ…‹èˆ‡è³‡æ–™ç‰ˆæœ¬ï¼Œå¿…è¦æ™‚é‡æ–°è¼‰å…¥
    async function checkSystemStatus() {
      try {
        showStatus('ğŸ’“ Checking...', 'loading');
        debugLog('Calling keepalive ...');
        let data;
        if (isGASEnv()) {
          data = await new Promise((resolve, reject) => {
            google.script.run
              .withSuccessHandler((d) => { try { debugLog('keepalive response (GAS): ' + JSON.stringify(d)); } catch (_) { }; resolve(d); })
              .withFailureHandler(err => {
                const msg = (err && err.message) ? err.message : (typeof err === 'string' ? err : 'GAS error');
                reject(new Error(msg));
              })
              .getKeepAliveData();
          });
        } else {
          const apiUrl = `${window.location.href.split('?')[0]}?path=keepalive`;
          const resp = await fetch(apiUrl, { headers: { 'Accept': 'application/json' } });
          if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
          data = await resp.json();
          try { debugLog('keepalive response (fetch): ' + JSON.stringify(data)); } catch (_) { }
        }

        if (data.status === 'OK') {
          const lastDataChangeTime = JSON.stringify(data.lastDataChange);
          const lastLocal = localStorage.getItem('lastDataChange');
          let statusMessage = `âœ… èª²ç¨‹è³‡æ–™æœ€å¾Œæ›´æ–°ï¼š${lastDataChangeTime}`;
          if (lastDataChangeTime !== lastLocal) {
            const v2 = await fetchV2();
            applyV2Data(v2);
            localStorage.setItem('lastDataChange', lastDataChangeTime);
          }
          if (data.systemConfig && data.systemConfig.KeepAliveInterval) {
            const newMin = Number(data.systemConfig.KeepAliveInterval);
            if (!isNaN(newMin) && newMin > 0) {
              const prevMin = window.__keepAliveMinutes || 0;
              // å¯«å…¥ localStorage ä¾›ä¸‹æ¬¡è¼‰å…¥ä½¿ç”¨
              localStorage.setItem('keepAliveInterval', JSON.stringify(newMin));
              if (newMin !== prevMin) {
                scheduleKeepalive(newMin);
              }
            }
          }
          showStatus(statusMessage, 'success');
        } else {
          showStatus('âš ï¸ ç³»çµ±ç‹€æ…‹ç•°å¸¸', 'error');
        }
      } catch (e) {
        debugLog(e?.message || String(e));
        showStatus('âŒ Keepalive å¤±æ•—: ' + (e?.message || e), 'error');
      }
    }

    async function init() {
      try {
        const data = await fetchV2();
        debugLog('v2 loaded');
        applyV2Data(data);
      } catch (e) {
        debugLog(e?.message || String(e));
      }
    }

    // keepalive æ’ç¨‹å™¨ï¼šå¯å‹•æ…‹èª¿æ•´é–“éš”
    let __keepAliveTimerId = null;
    window.__keepAliveMinutes = 0;
    function scheduleKeepalive(min) {
      if (__keepAliveTimerId) { clearInterval(__keepAliveTimerId); __keepAliveTimerId = null; }
      window.__keepAliveMinutes = min;
      __keepAliveTimerId = setInterval(checkSystemStatus, min * 60 * 1000);
      debugLog(`Keepalive scheduled: ${min} min`);
    }

    // åˆå§‹åŒ– Debug Levelï¼š?debug=0|1|2 å„ªå…ˆï¼Œå…¶æ¬¡ localStorage('debugLevel')ï¼Œé è¨­ 1
    (function initDebugLevel() {
      try {
        const qs = new URLSearchParams(window.location.search);
        const stored = localStorage.getItem('debugLevel');
        let level = 1;
        if (qs.has('debug')) {
          const v = Number(qs.get('debug'));
          if (!Number.isNaN(v)) level = Math.max(0, Math.min(2, v));
        } else if (stored !== null) {
          const v = Number(stored);
          if (!Number.isNaN(v)) level = Math.max(0, Math.min(2, v));
        }
        window.__debugLevel = level;
      } catch (_) { window.__debugLevel = 1; }
    })();

    document.addEventListener('DOMContentLoaded', () => {
      init();
      runEveryMinuteAtZeroSecond();
      scheduleMidnightTask();
      // å•Ÿå‹• keepalive å®šæ™‚å™¨ï¼ˆé è¨­ 5 åˆ†é˜ï¼Œæˆ–ä½¿ç”¨ localStorage ä¸Šæ¬¡å€¼ï¼‰
      const fallbackMin = 5;
      const stored = localStorage.getItem('keepAliveInterval');
      const initialMin = Number(stored ? JSON.parse(stored) : NaN) || fallbackMin;
      scheduleKeepalive(initialMin);
      // ä¹Ÿç«‹å³åšä¸€æ¬¡ keepalive
      checkSystemStatus();

      // å°å·¥å…·æŒ‰éˆ•ï¼šæ˜ç¢ºä½œç‚º Debug é–‹/é—œï¼Œä¸¦å›ºå®š header å…§å«ç­‰ç´šé¸å–®
      const toolsBtn = document.getElementById('tools-btn');
      const debugDiv = document.getElementById('debug-log');
      const debugLevelSel = document.getElementById('debug-level-select');
      if (debugLevelSel) {
        try { debugLevelSel.value = String(window.__debugLevel ?? 1); } catch (_) {}
        debugLevelSel.addEventListener('change', (e) => {
          const v = Number(e.target.value);
          const lvl = (!Number.isNaN(v)) ? Math.max(0, Math.min(2, v)) : 1;
          window.__debugLevel = lvl;
          try { localStorage.setItem('debugLevel', String(lvl)); } catch (_) {}
          debugLog(`Debug level set to ${lvl}`, 0);
        });
      }
      if (toolsBtn && debugDiv) {
        toolsBtn.addEventListener('click', () => {
          const isHidden = (debugDiv.style.display === 'none' || debugDiv.style.display === '');
          if (isHidden) { debugDiv.style.display = 'block'; toolsBtn.classList.add('active'); toolsBtn.title = 'éš±è—é™¤éŒ¯ç´€éŒ„'; }
          else { debugDiv.style.display = 'none'; toolsBtn.classList.remove('active'); toolsBtn.title = 'é¡¯ç¤ºé™¤éŒ¯ç´€éŒ„'; }
        });
      }
    });
  </script>
</body>

</html>