<!DOCTYPE html>
<html lang="zh-Hant">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dhamma Gong v2</title>
  <style>
    .play-button {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 30vh;
      background: #707070;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      color: #fff;
      font-size: 5vh;
      font-weight: bold;
      margin-bottom: 10px;
    }

    .play-button.flash {
      animation: flash-bg 3s ease-in-out infinite;
    }

    @keyframes flash-bg {
      0% {
        background: #707070;
      }

      50% {
        background: #212121;
      }

      100% {
        background: #707070;
      }
    }

    .play-text {
      flex-grow: 1;
    }

    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #f5f5f5;
    }

    .container {
      max-width: 100%;
      margin: 0 auto;
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, .1);
    }

    .status {
      padding: 10px;
      margin-bottom: 15px;
      border-radius: 4px;
    }

    .status.loading {
      background: #d1ecf1;
      color: #0c5460;
    }

    .status.success {
      background: #d4edda;
      color: #155724;
    }

    .status.error {
      background: #f8d7da;
      color: #721c24;
    }

    .hidden {
      display: none;
    }

    .date-block {
      border: 1px solid #ccc;
      padding: 10px;
      margin-bottom: 10px;
      background: #fff;
    }
  </style>
  <script>
    function debugLog(msg) {
      const logDiv = document.getElementById('debug-log');
      const now = new Date().toLocaleTimeString();
      if (typeof msg !== 'string') msg = JSON.stringify(msg);
      if (logDiv) { logDiv.innerHTML += `<div>[${now}] ${msg}</div>`; logDiv.scrollTop = logDiv.scrollHeight; }
      console.log('[DEBUG]', msg);
    }
  </script>
</head>

<body>
  <button class="play-button" onclick="playAlarm()">
    <div class="play-text">é»æ­¤æ‰‹å‹•æ•²é˜<br />â–¶ï¸</div>
  </button>

  <div class="container">
    <div id="status" class="status hidden"></div>
    <div id="audio-unlock" class="status">è«‹é»æ“Šç•«é¢ä»¥å•Ÿç”¨é˜è²ğŸ”“</div>
    <button id="debug-log-toggle" style="margin-bottom:8px;">é¡¯ç¤ºé™¤éŒ¯ç´€éŒ„</button>
    <div id="debug-log"
      style="display:none;background:#222;color:#0f0;font-size:12px;max-height:200px;overflow:auto;padding:8px;margin-bottom:12px;border-radius:6px;">
    </div>
    <div id="bell-log" style="background:#fff;border:1px solid #ddd;border-radius:6px;padding:8px;margin-bottom:12px;">
    </div>
    <div id="date-list"></div>
  </div>

  <audio id="alarm-sound" type="audio/mp3" preload="auto">
    <source src="">
  </audio>

  <script>
    // å…§åµŒé˜è²éŸ³æª”ï¼ˆèˆ‡èˆŠç‰ˆä¸€è‡´ï¼‰
    <?!= include('belljs') ?>

    const dateList = document.getElementById('date-list');
    const alarmSound = document.getElementById('alarm-sound');
    let source = alarmSound.querySelector('source');
    if (!source) { source = document.createElement('source'); alarmSound.appendChild(source); }
    source.src = BELL_BASE64; alarmSound.load();

    // éŸ³è¨Šè§£é–
    const audioUnlockDiv = document.getElementById('audio-unlock');
    let audioUnlocked = false;
    function showAudioUnlockMsg(msg) { audioUnlockDiv.textContent = msg; audioUnlockDiv.classList.remove('hidden'); }
    function hideAudioUnlockMsg() { audioUnlockDiv.classList.add('hidden'); }
    function unlockAudio() {
      if (audioUnlocked) return;
      alarmSound.muted = true;
      alarmSound.play().then(() => { alarmSound.pause(); alarmSound.currentTime = 0; alarmSound.muted = false; audioUnlocked = true; showAudioUnlockMsg('éŸ³è¨Šå·²è§£é–ï¼ğŸ”Š'); setTimeout(hideAudioUnlockMsg, 1200); })
        .catch(() => showAudioUnlockMsg('è«‹é»æ“Šç•«é¢ä»¥å•Ÿç”¨é˜è²ğŸ”“'));
    }
    window.addEventListener('touchstart', unlockAudio, { once: true });
    window.addEventListener('click', unlockAudio, { once: true });

    // ç‹€æ…‹é¡¯ç¤º
    function showStatus(message, type = 'loading') {
      const el = document.getElementById('status');
      el.textContent = message; el.className = `status ${type}`; el.classList.remove('hidden');
    }
    function hideStatus() { document.getElementById('status').classList.add('hidden'); }

    // åµæ¸¬æ˜¯å¦åœ¨ GAS åŸ·è¡Œç’°å¢ƒ
    function isGASEnv() {
      return (typeof google !== 'undefined' && google.script && google.script.run);
    }

    // è³‡æ–™æ¨¡å‹ï¼ˆèˆ‡èˆŠç‰ˆæ¸²æŸ“çµæ§‹ä¸€è‡´ï¼‰
    let alarms = []; // [{ date: 'YYYY-MM-DD', times: ['HH:MM', ...], bellTypes: { 'HH:MM': bellType|string|number } }]
    let bellConfig = {}; // { bellType: repeat }

    function renderAlarms() {
      dateList.innerHTML = '';
      alarms.forEach(a => {
        const block = document.createElement('div');
        block.className = 'date-block';
        block.innerHTML = `<h3>${a.date}</h3><p>ğŸ”” ${a.times.join(', ')}</p>`;
        dateList.appendChild(block);
      });
    }

    function getTodayDateFormatted() {
      const today = new Date();
      const y = today.getFullYear();
      const m = String(today.getMonth() + 1).padStart(2, '0');
      const d = String(today.getDate()).padStart(2, '0');
      return `${y}-${m}-${d}`;
    }

    function generateDateArray(startDateStr, days) {
      const result = []; const start = new Date(startDateStr);
      for (let i = 0; i < days; i++) { const dt = new Date(start); dt.setDate(start.getDate() + i); result.push(dt.toISOString().split('T')[0]); }
      return result;
    }

    // bell æ’­æ”¾
    let isAlarmPlaying = false; let pendingNextTimeout = null;
    function playVisualAlarm(enable = true) { const btn = document.querySelector('.play-button'); enable ? btn.classList.add('flash') : btn.classList.remove('flash'); }
    function updatePlayButton(isPlaying = false) { const t = document.querySelector('.play-text'); if (!t) return; t.innerHTML = isPlaying ? 'é»æ­¤åœæ­¢é˜è²<br/>â¹ï¸' : 'é»æ­¤æ‰‹å‹•æ•²é˜<br/>â–¶ï¸'; }
    function playSingleAlarm(current, total) { alarmSound.onended = null; alarmSound.onended = () => { alarmSound.load(); }; alarmSound.play().catch(e => debugLog('play error:' + e)); debugLog(`Bell played: ${current}/${total}`); }
    function stopAlarm() { if (!isAlarmPlaying) return; if (pendingNextTimeout) { clearTimeout(pendingNextTimeout); pendingNextTimeout = null; } alarmSound.pause(); alarmSound.currentTime = 0; playVisualAlarm(false); updatePlayButton(false); isAlarmPlaying = false; }
    function playAlarmSequence(times = 1, trigger = 'è‡ªå‹•') {
      if (times < 1) return; isAlarmPlaying = true; playVisualAlarm(true); updatePlayButton(true); let count = 0; const gapMs = 300; const bellDuration = 16;
      // é˜è²æ’­æ”¾ç´€éŒ„ï¼ˆèˆ‡èˆŠç‰ˆä¸€è‡´ï¼‰
      logBellPlay(trigger, times);
      function playNext() { if (!isAlarmPlaying) return; if (count >= times) { playVisualAlarm(false); updatePlayButton(false); isAlarmPlaying = false; return; } playSingleAlarm(count + 1, times); count++; pendingNextTimeout = setTimeout(playNext, (bellDuration * 1000) + gapMs); }
      playNext();
    }
    function playAlarm() { if (isAlarmPlaying) stopAlarm(); else playAlarmSequence(4, 'æ‰‹å‹•'); }

    function deletePastAlarms() { const today = getTodayDateFormatted(); alarms = alarms.filter(a => a.date >= today); }
    function sortAlarms() { alarms.sort((a, b) => new Date(a.date) - new Date(b.date)); alarms.forEach(a => a.times.sort((x, y) => x.localeCompare(y))); }

    // æ’­æ”¾é˜è²ç´€éŒ„ï¼ˆèˆ‡èˆŠç‰ˆä¸€è‡´ï¼‰
    function logBellPlay(type, times) {
      const logDiv = document.getElementById('bell-log');
      if (!logDiv) return;
      const now = new Date();
      const hh = String(now.getHours()).padStart(2, '0');
      const mm = String(now.getMinutes()).padStart(2, '0');
      const ss = String(now.getSeconds()).padStart(2, '0');
      const msg = `[${hh}:${mm}:${ss}] ${type} æ’­æ”¾é˜è² x${times}`;
      logDiv.innerHTML = `<div>${msg}</div>` + logDiv.innerHTML;
      const logs = logDiv.querySelectorAll('div');
      if (logs.length > 20) { for (let i = 20; i < logs.length; i++) logs[i].remove(); }
    }

    function runEveryMinuteAtZeroSecond() {
      const now = new Date(); const next = new Date(now); next.setSeconds(0); next.setMilliseconds(0); next.setMinutes(now.getMinutes() + 1);
      const delay = next - now;
      debugLog(`[tick] schedule next @ ${next.toLocaleTimeString()} (delay=${delay}ms)`);
      setTimeout(() => {
        const hh = String(next.getHours()).padStart(2, '0'); const mm = String(next.getMinutes()).padStart(2, '0'); const currentTime = `${hh}:${mm}`;
        const today = getTodayDateFormatted();
        const hasAlarms = !!(alarms && alarms.length > 0);
        const dateMatch = hasAlarms ? (alarms[0].date === today) : false;
        const timeMatch = hasAlarms && dateMatch ? alarms[0].times.includes(currentTime) : false;
        debugLog(`[tick] now=${today} ${currentTime}, hasAlarms=${hasAlarms}, dateMatch=${dateMatch}, timeMatch=${timeMatch}`);
        if (hasAlarms && dateMatch && timeMatch) {
          const v = alarms[0].bellTypes[currentTime] ?? 1;
          const repeat = (typeof v === 'number') ? v : (bellConfig[String(v)] || 1); // ä»¥ BellConfig æ±ºå®šæ•²å¹¾è²
          debugLog(`è‡ªå‹•æ’­æ”¾é˜è²: repeat=${repeat}`);
          playAlarmSequence(repeat, 'è‡ªå‹•');
        } else {
          if (!hasAlarms) debugLog('[tick] skip: no alarms');
          else if (!dateMatch) debugLog(`[tick] skip: date not match (first=${alarms[0]?.date}, today=${today})`);
          else if (!timeMatch) debugLog(`[tick] skip: ${currentTime} not in [${alarms[0].times.join(', ')}]`);
        }
        runEveryMinuteAtZeroSecond();
      }, delay);
    }

    // æ¯æ—¥ 00:00 æ¸…ç†éå»æ—¥æœŸä¸¦åˆ·æ–°åˆ—è¡¨
    function scheduleMidnightTask() {
      const now = new Date();
      const nextMidnight = new Date(now);
      nextMidnight.setDate(now.getDate() + 1);
      nextMidnight.setHours(0, 0, 0, 0);
      const delay = nextMidnight - now;
      debugLog(`[midnight] schedule @ ${nextMidnight.toLocaleString()} (in ${delay}ms)`);
      setTimeout(() => {
        try {
          debugLog('[midnight] running: deletePastAlarms + refresh');
          deletePastAlarms();
          sortAlarms();
          renderAlarms();
        } finally {
          scheduleMidnightTask();
        }
      }, delay);
    }

    // è®€å– v2 API
    async function fetchV2() {
      debugLog('Calling v2/course ...');
      if (isGASEnv()) {
        // ç›´æ¥å‘¼å« GAS å‡½å¼ï¼Œé¿å…å› éƒ¨ç½²æˆ–æ¬Šé™å°è‡´çš„ HTML å›å‚³
        return await new Promise((resolve, reject) => {
          try {
            google.script.run
              .withSuccessHandler((data) => { try { debugLog('v2/course response (GAS): ' + JSON.stringify(data)); } catch (_) { }; resolve(data); })
              .withFailureHandler(err => {
                const msg = (err && err.message) ? err.message : (typeof err === 'string' ? err : 'GAS error');
                reject(new Error(msg));
              })
              .exportBellScheduleJSONV2();
          } catch (e) { reject(e); }
        });
      }
      // é GAS ç’°å¢ƒå‚™æ´ï¼šfetch è·¯ç”±ç«¯é»
      const apiUrl = `${window.location.href.split('?')[0]}?path=v2/course`;
      const resp = await fetch(apiUrl, { headers: { 'Accept': 'application/json' } });
      const text = await resp.text();
      if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${text.slice(0, 120)}`);
      try { const data = JSON.parse(text); try { debugLog('v2/course response (fetch): ' + JSON.stringify(data)); } catch (_) { }; return data; } catch (e) { throw new Error("Unexpected token '<', response is not JSON"); }
    }

    function applyV2Data(v2) {
      // v2 compact: { CourseSchedule:[{startDate,courseType}], CourseTypeDays:{ct:[patternKey...]}, DailyPatternBells:{ct:{patternKey:[{time,bellType}]}} , BellConfig }
      alarms = [];
      bellConfig = v2.BellConfig || {};
      const courseSchedule = Array.isArray(v2.CourseSchedule) ? v2.CourseSchedule : [];
      const ctd = v2.CourseTypeDays || {};
      const dpb = v2.DailyPatternBells || {};

      courseSchedule.forEach(sch => {
        const ct = sch.courseType;
        const dayKeys = Array.isArray(ctd[ct]) ? ctd[ct] : [];
        const dates = generateDateArray(sch.startDate, dayKeys.length);
        dates.forEach((date, idx) => {
          const key = dayKeys[idx]; if (!key) return;
          const bells = (((dpb || {})[ct] || {})[key]) || [];
          const times = []; const bellTypes = {};
          bells.forEach(b => { if (b && b.time) { times.push(b.time); bellTypes[b.time] = (b.bellType !== undefined ? b.bellType : b.count); } });
          const exist = alarms.find(a => a.date === date);
          if (exist) {
            times.forEach(t => { if (!exist.times.includes(t)) exist.times.push(t); exist.bellTypes[t] = bellTypes[t]; });
            exist.times.sort((x, y) => x.localeCompare(y));
          } else {
            alarms.push({ date, times: Array.from(new Set(times)).sort((x, y) => x.localeCompare(y)), bellTypes });
          }
        });
      });

      deletePastAlarms(); sortAlarms(); renderAlarms();
    }

    // keepaliveï¼šå–å¾—ç‹€æ…‹èˆ‡è³‡æ–™ç‰ˆæœ¬ï¼Œå¿…è¦æ™‚é‡æ–°è¼‰å…¥
    async function checkSystemStatus() {
      try {
        showStatus('ğŸ’“ Checking...', 'loading');
        debugLog('Calling keepalive ...');
        let data;
        if (isGASEnv()) {
          data = await new Promise((resolve, reject) => {
            google.script.run
              .withSuccessHandler((d) => { try { debugLog('keepalive response (GAS): ' + JSON.stringify(d)); } catch (_) { }; resolve(d); })
              .withFailureHandler(err => {
                const msg = (err && err.message) ? err.message : (typeof err === 'string' ? err : 'GAS error');
                reject(new Error(msg));
              })
              .getKeepAliveData();
          });
        } else {
          const apiUrl = `${window.location.href.split('?')[0]}?path=keepalive`;
          const resp = await fetch(apiUrl, { headers: { 'Accept': 'application/json' } });
          if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
          data = await resp.json();
          try { debugLog('keepalive response (fetch): ' + JSON.stringify(data)); } catch (_) { }
        }

        if (data.status === 'OK') {
          const lastDataChangeTime = JSON.stringify(data.lastDataChange);
          const lastLocal = localStorage.getItem('lastDataChange');
          let statusMessage = `âœ… èª²ç¨‹è³‡æ–™æœ€å¾Œæ›´æ–°ï¼š${lastDataChangeTime}`;
          if (lastDataChangeTime !== lastLocal) {
            const v2 = await fetchV2();
            applyV2Data(v2);
            localStorage.setItem('lastDataChange', lastDataChangeTime);
          }
          if (data.systemConfig && data.systemConfig.KeepAliveInterval) {
            const newMin = Number(data.systemConfig.KeepAliveInterval);
            if (!isNaN(newMin) && newMin > 0) {
              const prevMin = window.__keepAliveMinutes || 0;
              // å¯«å…¥ localStorage ä¾›ä¸‹æ¬¡è¼‰å…¥ä½¿ç”¨
              localStorage.setItem('keepAliveInterval', JSON.stringify(newMin));
              if (newMin !== prevMin) {
                scheduleKeepalive(newMin);
              }
            }
          }
          showStatus(statusMessage, 'success');
        } else {
          showStatus('âš ï¸ ç³»çµ±ç‹€æ…‹ç•°å¸¸', 'error');
        }
      } catch (e) {
        debugLog(e?.message || String(e));
        showStatus('âŒ Keepalive å¤±æ•—: ' + (e?.message || e), 'error');
      }
    }

    async function init() {
      try {
        const data = await fetchV2();
        debugLog('v2 loaded');
        applyV2Data(data);
      } catch (e) {
        debugLog(e?.message || String(e));
      }
    }

    // keepalive æ’ç¨‹å™¨ï¼šå¯å‹•æ…‹èª¿æ•´é–“éš”
    let __keepAliveTimerId = null;
    window.__keepAliveMinutes = 0;
    function scheduleKeepalive(min) {
      if (__keepAliveTimerId) { clearInterval(__keepAliveTimerId); __keepAliveTimerId = null; }
      window.__keepAliveMinutes = min;
      __keepAliveTimerId = setInterval(checkSystemStatus, min * 60 * 1000);
      debugLog(`Keepalive scheduled: ${min} min`);
    }

    document.addEventListener('DOMContentLoaded', () => {
      init();
      runEveryMinuteAtZeroSecond();
      scheduleMidnightTask();
      // å•Ÿå‹• keepalive å®šæ™‚å™¨ï¼ˆé è¨­ 5 åˆ†é˜ï¼Œæˆ–ä½¿ç”¨ localStorage ä¸Šæ¬¡å€¼ï¼‰
      const fallbackMin = 5;
      const stored = localStorage.getItem('keepAliveInterval');
      const initialMin = Number(stored ? JSON.parse(stored) : NaN) || fallbackMin;
      scheduleKeepalive(initialMin);
      // ä¹Ÿç«‹å³åšä¸€æ¬¡ keepalive
      checkSystemStatus();

      // é™¤éŒ¯ç´€éŒ„é¡¯ç¤º/éš±è—
      const toggleBtn = document.getElementById('debug-log-toggle');
      const debugDiv = document.getElementById('debug-log');
      if (toggleBtn && debugDiv) {
        toggleBtn.addEventListener('click', () => {
          const isHidden = (debugDiv.style.display === 'none');
          debugDiv.style.display = isHidden ? 'block' : 'none';
          toggleBtn.textContent = isHidden ? 'éš±è—é™¤éŒ¯ç´€éŒ„' : 'é¡¯ç¤ºé™¤éŒ¯ç´€éŒ„';
        });
      }
    });
  </script>
</body>

</html>