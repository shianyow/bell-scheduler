<!DOCTYPE html>
<html lang="zh-Hant">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dhamma Gong v2</title>
  <style>
    .play-button {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 30vh;
      background: #707070;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      color: #fff;
      font-size: 5vh;
      font-weight: bold;
      margin-bottom: 10px;
    }

    .play-button.flash {
      animation: flash-bg 3s ease-in-out infinite;
    }

    @keyframes flash-bg {
      0% {
        background: #707070;
      }

      50% {
        background: #212121;
      }

      100% {
        background: #707070;
      }
    }

    .play-text {
      flex-grow: 1;
    }

    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #f5f5f5;
    }

    .container {
      max-width: 100%;
      margin: 0 auto;
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, .1);
    }

    .status {
      padding: 10px;
      margin-bottom: 15px;
      border-radius: 4px;
    }

    .status.loading {
      background: #d1ecf1;
      color: #0c5460;
    }

    .status.success {
      background: #d4edda;
      color: #155724;
    }

    .status.error {
      background: #f8d7da;
      color: #721c24;
    }

    .hidden {
      display: none;
    }

    .date-block {
      border: 1px solid #ccc;
      padding: 10px;
      margin-bottom: 8px;
      background: #fff;
    }
    /* 今日強調 */
    .date-block.today {
      border-left: 4px solid #28a745; /* 綠色左邊條 */
      background: #f5fff7;            /* 很淡的綠底 */
    }
    /* 控制列置頂 */
    .controls {
      position: sticky;
      top: 0;
      background: #fff;
      z-index: 5;
      padding: 8px 0;
      box-shadow: 0 2px 6px rgba(0, 0, 0, .04);
    }
    /* Logs 固定高度與滾動 */
    #bell-log, #debug-log {
      max-height: 200px;
      overflow: auto;
    }
    /* 狀態列 + 工具按鈕排列 */
    .status-row { display: flex; align-items: center; gap: 8px; }
    .status-row .spacer { flex: 1; }
    .tool-btn { background: transparent; border: 1px solid #ddd; color: #555; padding: 2px 10px; border-radius: 4px; font-size: inherit; }
    .tool-btn:hover { background: #f3f3f3; }
    .tool-btn.active { background: #eef6ff; color: #0b74da; border-color: #b6dbff; }
    /* Debug 區塊固定標頭 */
    #debug-log { background:#222; color:#0f0; }
    #debug-log .debug-header { position: sticky; top: 0; background:#111; color:#9f9; padding:6px 8px; border-bottom:1px solid #333; display:flex; align-items:center; gap:8px; z-index:1; }
    #debug-log .debug-header label { font-size:12px; color:#9f9; }
    #debug-entries { padding:8px; font-size:12px; }
  </style>
  <script>
    // === i18n (ZH/EN) ===
    const TRANSLATIONS = {
      zh: {
        'play_button.play': '點此手動敲鐘<br />▶️',
        'play_button.stop': '點此停止鐘聲<br/>⏹️',
        'audio.unlock_prompt': '請點擊畫面以啟用鐘聲🔓',
        'audio.unlocked': '音訊已解鎖！🔊',
        'status.checking': '💓 檢查中...',
        'status.ok_prefix': '✅ 課程資料最後更新：',
        'status.system_abnormal': '⚠️ 系統狀態異常',
        'status.keepalive_failed_prefix': '❌ Keepalive 失敗: ',
        'tools.show_debug': '顯示 Debug Log',
        'tools.hide_debug': '隱藏除錯紀錄',
        'tools.lang_toggle': '切換語言',
        'debug.title': 'Debug Log',
        'debug.level.0': '0 關閉',
        'debug.level.1': '1 一般',
        'debug.level.2': '2 詳細',
        'log.type.auto': '自動',
        'log.type.manual': '手動',
        'log.played': '播放鐘聲'
      },
      en: {
        'play_button.play': 'Click To Play Gong<br />▶️',
        'play_button.stop': 'Click To Stop Gong<br/>⏹️',
        'audio.unlock_prompt': 'Tap anywhere to enable sound 🔓',
        'audio.unlocked': 'Audio unlocked! 🔊',
        'status.checking': '💓 Checking...',
        'status.ok_prefix': '✅ Last data update: ',
        'status.system_abnormal': '⚠️ System abnormal',
        'status.keepalive_failed_prefix': '❌ Keepalive failed: ',
        'tools.show_debug': 'Show Debug Log',
        'tools.hide_debug': 'Hide Debug Log',
        'tools.lang_toggle': 'Switch language',
        'debug.title': 'Debug Log',
        'debug.level.0': '0 Off',
        'debug.level.1': '1 Normal',
        'debug.level.2': '2 Verbose',
        'log.type.auto': 'Auto',
        'log.type.manual': 'Manual',
        'log.played': 'Gong played'
      }
    };
    function getLang() {
      try { return localStorage.getItem('lang') || 'zh'; } catch (_) { return 'zh'; }
    }
    function setLang(lang) {
      const v = (lang === 'en') ? 'en' : 'zh';
      try { localStorage.setItem('lang', v); } catch (_) {}
      try { document.documentElement.lang = (v === 'en' ? 'en' : 'zh-Hant'); } catch (_) {}
    }
    function t(key) {
      const lang = getLang();
      return (TRANSLATIONS[lang] && TRANSLATIONS[lang][key]) || TRANSLATIONS.zh[key] || key;
    }
    function i18nApply() {
      // Apply static elements with data-i18n
      document.querySelectorAll('[data-i18n]').forEach(el => {
        const k = el.getAttribute('data-i18n');
        const asHtml = el.getAttribute('data-i18n-html') === '1';
        const txt = t(k);
        if (asHtml) el.innerHTML = txt; else el.textContent = txt;
      });
      // Attributes
      document.querySelectorAll('[data-i18n-title]').forEach(el => { el.title = t(el.getAttribute('data-i18n-title')); });
      // Debug title
      const dt = document.getElementById('debug-title'); if (dt) dt.textContent = t('debug.title');
      // Debug level options
      const d0 = document.querySelector('#debug-level-select option[value="0"]'); if (d0) d0.textContent = t('debug.level.0');
      const d1 = document.querySelector('#debug-level-select option[value="1"]'); if (d1) d1.textContent = t('debug.level.1');
      const d2 = document.querySelector('#debug-level-select option[value="2"]'); if (d2) d2.textContent = t('debug.level.2');
      // Tools button titles
      const toolsBtn = document.getElementById('tools-btn');
      const debugDiv = document.getElementById('debug-log');
      if (toolsBtn && debugDiv) {
        const isHidden = (debugDiv.style.display === 'none' || debugDiv.style.display === '');
        toolsBtn.title = isHidden ? t('tools.show_debug') : t('tools.hide_debug');
      }
    }
    // Debug 等級：0=關閉, 1=一般, 2=詳細
    function debugLog(msg, level = 1) {
      const threshold = window.__debugLevel ?? 1;
      if (level > threshold) return;
      const now = new Date().toLocaleTimeString();
      const entries = document.getElementById('debug-entries');
      if (typeof msg !== 'string') msg = JSON.stringify(msg);
      if (entries) {
        const row = document.createElement('div');
        row.textContent = `[${now}] ${msg}`;
        entries.appendChild(row);
        // 限制最大行數，避免長時間運行造成 DOM 過大
        const MAX_DEBUG_LINES = 200;
        const nodes = entries.querySelectorAll('div');
        const overflow = nodes.length - MAX_DEBUG_LINES;
        if (overflow > 0) {
          for (let i = 0; i < overflow; i++) nodes[i].remove();
        }
        const container = document.getElementById('debug-log');
        if (container) container.scrollTop = container.scrollHeight;
      }
      try { console.log('[DEBUG]', msg); } catch (_) { }
    }
  </script>
</head>

<body>
  <button class="play-button" onclick="playAlarm()">
    <div class="play-text" id="play-text" data-i18n="play_button.play" data-i18n-html="1">點此手動敲鐘<br />▶️</div>
  </button>

  <div class="container">
    <div class="status-row" style="margin-bottom:8px;">
      <div id="status" class="status hidden"></div>
      <div class="spacer"></div>
      <button id="lang-btn" class="tool-btn" data-i18n-title="tools.lang_toggle" title="切換語言">🌐</button>
      <button id="tools-btn" class="tool-btn" data-i18n-title="tools.show_debug" title="顯示 Debug Log">🔎</button>
    </div>
    <div id="audio-unlock" class="status" data-i18n="audio.unlock_prompt">請點擊畫面以啟用鐘聲🔓</div>
    <div id="debug-log" style="display:none; max-height:200px; overflow:auto; margin-bottom:12px; border-radius:6px;">
      <div class="debug-header">
        <span id="debug-title" style="font-weight:600;">Debug Log</span>
        <div class="spacer"></div>
        <select id="debug-level-select" style="font-size:12px; background:#1a1a1a; color:#9f9; border:1px solid #333; border-radius:4px; padding:2px 6px;">
          <option value="0">0 關閉</option>
          <option value="1" selected>1 一般</option>
          <option value="2">2 詳細</option>
        </select>
      </div>
      <div id="debug-entries"></div>
    </div>
    <div id="bell-log" style="background:#fff;border:1px solid #ddd;border-radius:6px;padding:8px;margin-bottom:12px;">
    </div>
    <div id="date-list"></div>
  </div>

  <audio id="alarm-sound" type="audio/mp3" preload="auto">
    <source src="">
  </audio>

  <script>
    // 內嵌鐘聲音檔
    <?!= include('bell3js') ?>

    const dateList = document.getElementById('date-list');
    const alarmSound = document.getElementById('alarm-sound');
    let source = alarmSound.querySelector('source');
    if (!source) { source = document.createElement('source'); alarmSound.appendChild(source); }
    source.src = BELL_BASE64; alarmSound.load();
    // 明確設定音量與靜音狀態
    alarmSound.muted = false;
    alarmSound.volume = 1.0;

    // Web Audio（iOS 友善）：單一 AudioContext、預先解碼音檔，之後用 BufferSource 疊加播放
    let audioCtx = null;      // AudioContext
    let bellBuffer = null;    // 解碼後的 AudioBuffer
    let gainNode = null;      // 音量控制

    // 音訊解鎖
    const audioUnlockDiv = document.getElementById('audio-unlock');
    let audioUnlocked = false;
    function showAudioUnlockMsg(msg) { audioUnlockDiv.textContent = msg; audioUnlockDiv.classList.remove('hidden'); }
    function hideAudioUnlockMsg() { audioUnlockDiv.classList.add('hidden'); }
    async function unlockAudio() {
      if (audioUnlocked) return;
      try {
        // 1) 嘗試建立/恢復 Web Audio Context
        const AC = window.AudioContext || window.webkitAudioContext;
        if (AC) {
          if (!audioCtx) {
            audioCtx = new AC();
            gainNode = audioCtx.createGain();
            gainNode.gain.value = 1.0;
            gainNode.connect(audioCtx.destination);
          }
          if (audioCtx.state === 'suspended') { await audioCtx.resume(); }
          // 2) 預先解碼 BELL_BASE64（先 atob，再失敗時 fallback fetch）
          if (!bellBuffer) {
            let decoded = false;
            try {
              const commaIdx = BELL_BASE64.indexOf(',');
              const b64 = commaIdx >= 0 ? BELL_BASE64.slice(commaIdx + 1) : BELL_BASE64;
              const binary = atob(b64);
              const len = binary.length;
              const bytes = new Uint8Array(len);
              for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
              debugLog(`Decoding bell buffer (atob), bytes=${len}`);
              bellBuffer = await new Promise((res, rej) => { audioCtx.decodeAudioData(bytes.buffer, res, rej); });
              decoded = true;
              debugLog(`Bell buffer decoded (atob): duration=${bellBuffer.duration.toFixed(2)}s`);
            } catch (e1) {
              debugLog('decodeAudioData via atob failed: ' + (e1?.message || e1));
              try {
                const resp = await fetch(BELL_BASE64);
                const arr = await resp.arrayBuffer();
                debugLog(`Decoding bell buffer (fetch), bytes=${arr.byteLength}`);
                bellBuffer = await new Promise((res, rej) => { audioCtx.decodeAudioData(arr, res, rej); });
                decoded = true;
                debugLog(`Bell buffer decoded (fetch): duration=${bellBuffer.duration.toFixed(2)}s`);
              } catch (e2) {
                debugLog('decodeAudioData via fetch failed: ' + (e2?.message || e2));
              }
            }
            if (!decoded) {
              debugLog('Bell buffer not decoded, will fallback to HTMLAudio path.');
            }
          }
        }
        // 3) 同時也嘗試解鎖 HTMLAudio（做為後援）
        try {
          alarmSound.muted = true;
          await alarmSound.play();
          alarmSound.pause(); alarmSound.currentTime = 0; alarmSound.muted = false;
        } catch (_) { /* ignore */ }

        audioUnlocked = true;
        showAudioUnlockMsg(t('audio.unlocked'));
        setTimeout(hideAudioUnlockMsg, 1200);
      } catch (_) {
        showAudioUnlockMsg(t('audio.unlock_prompt'));
      }
    }
    window.addEventListener('touchstart', unlockAudio, { once: true });
    window.addEventListener('click', unlockAudio, { once: true });

    // 等待音訊解鎖（避免首次點擊時解鎖與播放競態）
    async function ensureAudioUnlocked(timeoutMs = 1200) {
      if (audioUnlocked) return true;
      try { await unlockAudio(); } catch (_) { }
      const start = Date.now();
      while (!audioUnlocked && (Date.now() - start) < timeoutMs) {
        await new Promise(r => setTimeout(r, 50));
      }
      if (!audioUnlocked) { showAudioUnlockMsg(t('audio.unlock_prompt')); }
      return audioUnlocked;
    }

    // 狀態顯示
    function showStatus(message, type = 'loading') {
      const el = document.getElementById('status');
      el.textContent = message; el.className = `status ${type}`; el.classList.remove('hidden');
    }
    function hideStatus() { document.getElementById('status').classList.add('hidden'); }

    // 偵測是否在 GAS 執行環境
    function isGASEnv() {
      return (typeof google !== 'undefined' && google.script && google.script.run);
    }

    // 資料模型（與舊版渲染結構一致）
    let alarms = []; // [{ date: 'YYYY-MM-DD', times: ['HH:MM', ...], bellTypes: { 'HH:MM': bellType|string|number } }]
    let bellConfig = {}; // { bellType: repeat }

    function renderAlarms() {
      dateList.innerHTML = '';
      const todayStr = getTodayDateFormatted();
      alarms.forEach(a => {
        const block = document.createElement('div');
        block.className = 'date-block' + (a.date === todayStr ? ' today' : '');
        block.innerHTML = `<h3>${a.date}</h3><p>🔔 ${a.times.join(', ')}</p>`;
        dateList.appendChild(block);
      });
    }

    function getTodayDateFormatted() {
      const today = new Date();
      const y = today.getFullYear();
      const m = String(today.getMonth() + 1).padStart(2, '0');
      const d = String(today.getDate()).padStart(2, '0');
      return `${y}-${m}-${d}`;
    }

    function generateDateArray(startDateStr, days) {
      const result = []; const start = new Date(startDateStr);
      for (let i = 0; i < days; i++) { const dt = new Date(start); dt.setDate(start.getDate() + i); result.push(dt.toISOString().split('T')[0]); }
      return result;
    }

    // bell 播放
    let isAlarmPlaying = false; let pendingNextTimeout = null;
    // 第一聲音量設定（可調）
    const FIRST_STRIKE_VOLUME = 0.35;   // 第一聲目標音量（其餘為 1.0）
    const FIRST_STRIKE_ATTACK_MUTE_MS = 0; // 第一聲前 30ms 靜音（非淡入），降低起始敲擊感
    // 追蹤目前正在播放的音軌
    const activeAudios = new Set();    // HTMLAudioElement 實例
    const activeSources = new Set();   // Web Audio BufferSource 實例
    function playVisualAlarm(enable = true) { const btn = document.querySelector('.play-button'); enable ? btn.classList.add('flash') : btn.classList.remove('flash'); }
    function updatePlayButton(isPlaying = false) { const el = document.querySelector('.play-text'); if (!el) return; el.innerHTML = isPlaying ? t('play_button.stop') : t('play_button.play'); }
    function playSingleAlarm(current, total) {
      // 尚未解鎖時避免觸發瀏覽器限制
      if (!audioUnlocked) { showAudioUnlockMsg(t('audio.unlock_prompt')); return; }
      // 優先使用 Web Audio（iOS 更穩定），否則退回 HTMLAudio
      if (audioCtx && bellBuffer) {
        try {
          if (audioCtx.state === 'suspended') { audioCtx.resume().catch(() => { }); }
          const src = audioCtx.createBufferSource();
          src.buffer = bellBuffer;
          // 針對每一聲建立獨立增益控制：第一聲 0.5，其餘 1.0（不影響其他同時播放的音軌）
          const perStrikeGain = audioCtx.createGain();
          const t0 = audioCtx.currentTime;
          const vol = (current === 1 ? FIRST_STRIKE_VOLUME : 1.0);
          if (current === 1) {
            // iOS 可感知：先靜音一小段再切到目標音量（步進，非淡入）
            perStrikeGain.gain.setValueAtTime(0.0, t0);
            perStrikeGain.gain.setValueAtTime(vol, t0 + FIRST_STRIKE_ATTACK_MUTE_MS / 1000);
          } else {
            perStrikeGain.gain.setValueAtTime(1.0, t0);
          }
          src.connect(perStrikeGain);
          perStrikeGain.connect(gainNode || audioCtx.destination);
          activeSources.add(src);
          src.onended = function () { try { src.disconnect(); } catch (_) { } activeSources.delete(src); };
          // 稍微延遲啟動，確保增益已設定（iOS 相容性）
          src.start(t0 + 0.01);
          debugLog(`Bell played (WebAudio): ${current}/${total} vol=${vol}`);
          return;
        } catch (e) {
          debugLog('webaudio play error:' + e);
        }
      }
      // 後援：HTMLAudio 新實例（注意：未解鎖時會被阻擋，因此前面已 return）
      const a = new Audio();
      a.src = BELL_BASE64;
      a.muted = false;
      if (current === 1) {
        // HTMLAudio：先靜音 30ms，再切到目標音量（步進）
        a.volume = 0.0;
        setTimeout(() => { try { a.volume = FIRST_STRIKE_VOLUME; } catch (_) {} }, FIRST_STRIKE_ATTACK_MUTE_MS);
      } else {
        a.volume = 1.0;
      }
      activeAudios.add(a);
      a.onended = function () { try { a.src = ''; } catch (_) { } activeAudios.delete(a); };
      a.play().catch((e) => debugLog('play error:' + e));
      debugLog(`Bell played (HTMLAudio): ${current}/${total} vol=${current === 1 ? FIRST_STRIKE_VOLUME : 1.0}`);
    }
    function stopAlarm() {
      if (!isAlarmPlaying) return;
      if (pendingNextTimeout) { clearTimeout(pendingNextTimeout); pendingNextTimeout = null; }
      // 停止所有還在播放的 HTMLAudio 實例
      activeAudios.forEach((a) => {
        try { a.pause(); } catch (_) { }
        try { a.src = ''; } catch (_) { }
      });
      activeAudios.clear();
      // 停止所有 Web Audio BufferSource
      activeSources.forEach((s) => { try { s.stop(0); } catch (_) { } try { s.disconnect(); } catch (_) { } });
      activeSources.clear();
      // 同時也重置預載用的 alarmSound（保持原有行為）
      try { alarmSound.pause(); alarmSound.currentTime = 0; } catch (_) { }
      playVisualAlarm(false);
      updatePlayButton(false);
      isAlarmPlaying = false;
    }
    async function playAlarmSequence(times = 1, trigger = 'auto') {
      if (times < 1) return;
      // 先確保已解鎖
      const ok = await ensureAudioUnlocked();
      if (!ok) return;
      // 嘗試恢復被暫停的 AudioContext
      if (audioCtx && audioCtx.state === 'suspended') { try { await audioCtx.resume(); } catch (_) { } }
      isAlarmPlaying = true; playVisualAlarm(true); updatePlayButton(true);
      let count = 0;
      // 每聲之間的觸發間隔（毫秒）。
      const strikeIntervalMs = 11000;
      // 鐘聲播放紀錄（與舊版一致）
      logBellPlay(trigger, times);
      function playNext() {
        if (!isAlarmPlaying) return;
        if (count >= times) { playVisualAlarm(false); updatePlayButton(false); isAlarmPlaying = false; return; }
        playSingleAlarm(count + 1, times);
        count++;
        pendingNextTimeout = setTimeout(playNext, strikeIntervalMs);
      }
      playNext();
    }
    async function playAlarm() { if (isAlarmPlaying) stopAlarm(); else await playAlarmSequence(4, 'manual'); }

    function deletePastAlarms() { const today = getTodayDateFormatted(); alarms = alarms.filter(a => a.date >= today); }
    function sortAlarms() { alarms.sort((a, b) => new Date(a.date) - new Date(b.date)); alarms.forEach(a => a.times.sort((x, y) => x.localeCompare(y))); }

    // 播放鐘聲紀錄（與舊版一致）
    function logBellPlay(type, times) {
      const logDiv = document.getElementById('bell-log');
      if (!logDiv) return;
      const now = new Date();
      const nowStr = now.toLocaleTimeString();
      const typeKey = (type === 'manual' || type === '手動') ? 'manual' : 'auto';
      const msg = `[${nowStr}] ${t('log.type.' + typeKey)} ${t('log.played')} x${times}`;
      logDiv.innerHTML = `<div>${msg}</div>` + logDiv.innerHTML;
      const logs = logDiv.querySelectorAll('div');
      if (logs.length > 20) { for (let i = 20; i < logs.length; i++) logs[i].remove(); }
    }

    // 更穩定的排程：每秒檢查一次，於該分鐘前幾秒內觸發，避免 setTimeout 漂移錯過 :00
    let __minuteTickerId = null;
    function startMinuteTicker() {
      if (__minuteTickerId) { clearInterval(__minuteTickerId); __minuteTickerId = null; }
      // 去重 key："YYYY-MM-DD HH:MM"
      window.__lastAutoFireKey = window.__lastAutoFireKey || '';
      __minuteTickerId = setInterval(() => {
        const t = new Date();
        const sec = t.getSeconds();
        // 僅在每分鐘的前 6 秒內檢查與觸發，避免重複與日常噪音
        if (sec > 5) return;
        const hh = String(t.getHours()).padStart(2, '0');
        const mm = String(t.getMinutes()).padStart(2, '0');
        const currentTime = `${hh}:${mm}`;
        const today = getTodayDateFormatted();
        const currentKey = `${today} ${currentTime}`;

        const hasAlarms = !!(alarms && alarms.length > 0);
        const dateMatch = hasAlarms ? (alarms[0].date === today) : false;
        const timeMatch = hasAlarms && dateMatch ? alarms[0].times.includes(currentTime) : false;
        if (sec <= 1) {
          // 僅在 0~1 秒時輸出詳細 tick 紀錄，避免洗版
          debugLog(`[tick] now=${today} ${currentTime} (sec=${sec}), hasAlarms=${hasAlarms}, dateMatch=${dateMatch}, timeMatch=${timeMatch}`, 2);
        }
        if (hasAlarms && dateMatch && timeMatch) {
          if (window.__lastAutoFireKey === currentKey) {
            if (sec <= 1) debugLog(`[tick] duplicate suppressed for ${currentKey}`, 2);
            return;
          }
          window.__lastAutoFireKey = currentKey;
          const v = alarms[0].bellTypes[currentTime] ?? 1;
          const repeat = (typeof v === 'number') ? v : (bellConfig[String(v)] || 1);
          debugLog(`自動播放鐘聲: repeat=${repeat}`);
          playAlarmSequence(repeat, 'auto');
        }
      }, 1000);
      debugLog('Minute ticker started (1s interval)');
    }

    // 每日 00:00 清理過去日期並刷新列表
    function scheduleMidnightTask() {
      const now = new Date();
      const nextMidnight = new Date(now);
      nextMidnight.setDate(now.getDate() + 1);
      nextMidnight.setHours(0, 0, 0, 0);
      const delay = nextMidnight - now;
      debugLog(`[midnight] schedule @ ${nextMidnight.toLocaleString()} (in ${delay}ms)`);
      setTimeout(() => {
        try {
          debugLog('[midnight] running: deletePastAlarms + refresh');
          deletePastAlarms();
          sortAlarms();
          renderAlarms();
        } finally {
          scheduleMidnightTask();
        }
      }, delay);
    }

    // 讀取 v2 API
    async function fetchV2() {
      debugLog('Calling v2/course ...');
      if (isGASEnv()) {
        // 直接呼叫 GAS 函式，避免因部署或權限導致的 HTML 回傳
        return await new Promise((resolve, reject) => {
          try {
            google.script.run
              .withSuccessHandler((data) => { try { debugLog('v2/course response (GAS): ' + JSON.stringify(data)); } catch (_) { }; resolve(data); })
              .withFailureHandler(err => {
                const msg = (err && err.message) ? err.message : (typeof err === 'string' ? err : 'GAS error');
                reject(new Error(msg));
              })
              .exportBellScheduleJSONV2();
          } catch (e) { reject(e); }
        });
      }
      // 非 GAS 環境備援：fetch 路由端點
      const apiUrl = `${window.location.href.split('?')[0]}?path=v2/course`;
      const resp = await fetch(apiUrl, { headers: { 'Accept': 'application/json' } });
      const text = await resp.text();
      if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${text.slice(0, 120)}`);
      try { const data = JSON.parse(text); try { debugLog('v2/course response (fetch): ' + JSON.stringify(data)); } catch (_) { }; return data; } catch (e) { throw new Error("Unexpected token '<', response is not JSON"); }
    }

    function applyV2Data(v2) {
      // v2 compact: { CourseSchedule:[{startDate,courseType}], CourseTypeDays:{ct:[patternKey...]}, DailyPatternBells:{ct:{patternKey:[{time,bellType}]}} , BellConfig }
      alarms = [];
      bellConfig = v2.BellConfig || {};
      const courseSchedule = Array.isArray(v2.CourseSchedule) ? v2.CourseSchedule : [];
      const ctd = v2.CourseTypeDays || {};
      const dpb = v2.DailyPatternBells || {};

      courseSchedule.forEach(sch => {
        const ct = sch.courseType;
        const dayKeys = Array.isArray(ctd[ct]) ? ctd[ct] : [];
        const dates = generateDateArray(sch.startDate, dayKeys.length);
        dates.forEach((date, idx) => {
          const key = dayKeys[idx]; if (!key) return;
          const bells = (((dpb || {})[ct] || {})[key]) || [];
          const times = []; const bellTypes = {};
          bells.forEach(b => { if (b && b.time) { times.push(b.time); bellTypes[b.time] = (b.bellType !== undefined ? b.bellType : b.count); } });
          const exist = alarms.find(a => a.date === date);
          if (exist) {
            times.forEach(t => { if (!exist.times.includes(t)) exist.times.push(t); exist.bellTypes[t] = bellTypes[t]; });
            exist.times.sort((x, y) => x.localeCompare(y));
          } else {
            alarms.push({ date, times: Array.from(new Set(times)).sort((x, y) => x.localeCompare(y)), bellTypes });
          }
        });
      });

      deletePastAlarms(); sortAlarms(); renderAlarms();
    }

    // keepalive：取得狀態與資料版本，必要時重新載入
    async function checkSystemStatus() {
      try {
        showStatus(t('status.checking'), 'loading');
        debugLog('Calling keepalive ...');
        let data;
        if (isGASEnv()) {
          data = await new Promise((resolve, reject) => {
            google.script.run
              .withSuccessHandler((d) => { try { debugLog('keepalive response (GAS): ' + JSON.stringify(d)); } catch (_) { }; resolve(d); })
              .withFailureHandler(err => {
                const msg = (err && err.message) ? err.message : (typeof err === 'string' ? err : 'GAS error');
                reject(new Error(msg));
              })
              .getKeepAliveData();
          });
        } else {
          const apiUrl = `${window.location.href.split('?')[0]}?path=keepalive`;
          const resp = await fetch(apiUrl, { headers: { 'Accept': 'application/json' } });
          if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
          data = await resp.json();
          try { debugLog('keepalive response (fetch): ' + JSON.stringify(data)); } catch (_) { }
        }

        if (data.status === 'OK') {
          const lastDataChangeTime = JSON.stringify(data.lastDataChange);
          const lastLocal = localStorage.getItem('lastDataChange');
          let statusMessage = `${t('status.ok_prefix')}${lastDataChangeTime}`;
          if (lastDataChangeTime !== lastLocal) {
            const v2 = await fetchV2();
            applyV2Data(v2);
            localStorage.setItem('lastDataChange', lastDataChangeTime);
          }
          if (data.systemConfig && data.systemConfig.KeepAliveInterval) {
            const newMin = Number(data.systemConfig.KeepAliveInterval);
            if (!isNaN(newMin) && newMin > 0) {
              const prevMin = window.__keepAliveMinutes || 0;
              // 寫入 localStorage 供下次載入使用
              localStorage.setItem('keepAliveInterval', JSON.stringify(newMin));
              if (newMin !== prevMin) {
                scheduleKeepalive(newMin);
              }
            }
          }
          showStatus(statusMessage, 'success');
        } else {
          showStatus(t('status.system_abnormal'), 'error');
        }
      } catch (e) {
        debugLog(e?.message || String(e));
        showStatus(t('status.keepalive_failed_prefix') + (e?.message || e), 'error');
      }
    }

    async function init() {
      try {
        const data = await fetchV2();
        debugLog('v2 loaded');
        applyV2Data(data);
      } catch (e) {
        debugLog(e?.message || String(e));
      }
    }

    // keepalive 排程器：可動態調整間隔
    let __keepAliveTimerId = null;
    window.__keepAliveMinutes = 0;
    function scheduleKeepalive(min) {
      if (__keepAliveTimerId) { clearInterval(__keepAliveTimerId); __keepAliveTimerId = null; }
      window.__keepAliveMinutes = min;
      __keepAliveTimerId = setInterval(checkSystemStatus, min * 60 * 1000);
      debugLog(`Keepalive scheduled: ${min} min`);
    }

    // 初始化 Debug Level：?debug=0|1|2 優先，其次 localStorage('debugLevel')，預設 1
    (function initDebugLevel() {
      try {
        const qs = new URLSearchParams(window.location.search);
        const stored = localStorage.getItem('debugLevel');
        let level = 1;
        if (qs.has('debug')) {
          const v = Number(qs.get('debug'));
          if (!Number.isNaN(v)) level = Math.max(0, Math.min(2, v));
        } else if (stored !== null) {
          const v = Number(stored);
          if (!Number.isNaN(v)) level = Math.max(0, Math.min(2, v));
        }
        window.__debugLevel = level;
      } catch (_) { window.__debugLevel = 1; }
    })();

    document.addEventListener('DOMContentLoaded', () => {
      // Initialize language
      setLang(getLang());
      i18nApply();
      updatePlayButton(false);
      init();
      startMinuteTicker();
      scheduleMidnightTask();
      // 啟動 keepalive 定時器（預設 5 分鐘，或使用 localStorage 上次值）
      const fallbackMin = 5;
      const stored = localStorage.getItem('keepAliveInterval');
      const initialMin = Number(stored ? JSON.parse(stored) : NaN) || fallbackMin;
      scheduleKeepalive(initialMin);
      // 也立即做一次 keepalive
      checkSystemStatus();

      // 小工具按鈕：明確作為 Debug 開/關，並固定 header 內含等級選單
      const toolsBtn = document.getElementById('tools-btn');
      const langBtn = document.getElementById('lang-btn');
      const debugDiv = document.getElementById('debug-log');
      const debugLevelSel = document.getElementById('debug-level-select');
      if (debugLevelSel) {
        try { debugLevelSel.value = String(window.__debugLevel ?? 1); } catch (_) {}
        debugLevelSel.addEventListener('change', (e) => {
          const v = Number(e.target.value);
          const lvl = (!Number.isNaN(v)) ? Math.max(0, Math.min(2, v)) : 1;
          window.__debugLevel = lvl;
          try { localStorage.setItem('debugLevel', String(lvl)); } catch (_) {}
          debugLog(`Debug level set to ${lvl}`, 0);
        });
        // Ensure options are localized on load
        i18nApply();
      }
      if (toolsBtn && debugDiv) {
        toolsBtn.addEventListener('click', () => {
          const isHidden = (debugDiv.style.display === 'none' || debugDiv.style.display === '');
          if (isHidden) { debugDiv.style.display = 'block'; toolsBtn.classList.add('active'); toolsBtn.title = t('tools.hide_debug'); }
          else { debugDiv.style.display = 'none'; toolsBtn.classList.remove('active'); toolsBtn.title = t('tools.show_debug'); }
        });
      }
      if (langBtn) {
        langBtn.addEventListener('click', () => {
          const next = (getLang() === 'en') ? 'zh' : 'en';
          setLang(next);
          i18nApply();
          updatePlayButton(isAlarmPlaying);
        });
      }
    });
  </script>
</body>

</html>
